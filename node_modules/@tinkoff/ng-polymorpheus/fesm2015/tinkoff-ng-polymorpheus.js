import { NgComponentOutlet, CommonModule } from '@angular/common';
import { InjectionToken, Injector, ChangeDetectorRef, Directive, Inject, Self, TemplateRef, ChangeDetectionStrategy, Component, ContentChild, Input, ViewChild, ViewContainerRef, Pipe, NgModule } from '@angular/core';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Use this token to access context within your components when
 * instantiating them through {\@link PolymorpheusOutletComponent}
 * @type {?}
 */
const POLYMORPHEUS_CONTEXT = new InjectionToken('Context from polymorpheus-outlet');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Wrapper class for a component that will be used as content for {\@link PolymorpheusOutletComponent}
 *
 * @param component — an Angular component to be dynamically created
 * @param injector — optional {\@link Injector} for lazy loaded module case
 * @template T, C
 */
class PolymorpheusComponent {
    /**
     * @param {?} component
     * @param {?=} injector
     */
    constructor(component, injector = null) {
        this.component = component;
        this.injector = injector;
    }
    /**
     * @param {?} injector
     * @param {?} context
     * @return {?}
     */
    createInjector(injector, context) {
        return Injector.create({
            parent: this.injector || injector,
            providers: [
                {
                    provide: POLYMORPHEUS_CONTEXT,
                    useValue: context,
                },
            ],
        });
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * ng-template wrapper directive also storing {\@link ChangeDetectorRef} to properly handle change detection.
 * @template T
 */
class PolymorpheusTemplate {
    /**
     * @param {?} template
     * @param {?} changeDetectorRef
     */
    constructor(template, changeDetectorRef) {
        this.template = template;
        this.changeDetectorRef = changeDetectorRef;
    }
    /**
     * @return {?}
     */
    check() {
        this.changeDetectorRef.markForCheck();
    }
}
PolymorpheusTemplate.decorators = [
    { type: Directive, args: [{
                selector: 'ng-template[polymorpheus]',
                exportAs: 'polymorpheus',
            },] }
];
/** @nocollapse */
PolymorpheusTemplate.ctorParameters = () => [
    { type: TemplateRef, decorators: [{ type: Inject, args: [TemplateRef,] }, { type: Self }] },
    { type: ChangeDetectorRef, decorators: [{ type: Inject, args: [ChangeDetectorRef,] }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Outlet instantiating {\@link PolymorpheusContent} with given context
 * @template C
 */
class PolymorpheusOutletComponent {
    /**
     * @param {?} injector
     */
    constructor(injector) {
        this.injector = injector;
        this.content = null;
        this.template = null;
    }
    /**
     * @return {?}
     */
    get primitive() {
        if (!this.content ||
            this.isComponent(this.content) ||
            this.isTemplate(this.content)) {
            return '';
        }
        return typeof this.content === 'function'
            ? this.content(this.context)
            : this.content;
    }
    /**
     * @param {?} content
     * @return {?}
     */
    isDirective(content) {
        return content instanceof PolymorpheusTemplate;
    }
    /**
     * @param {?} content
     * @return {?}
     */
    isTemplate(content) {
        return this.isDirective(content) || content instanceof TemplateRef;
    }
    /**
     * @param {?} content
     * @return {?}
     */
    isComponent(content) {
        return content instanceof PolymorpheusComponent;
    }
    /**
     * @param {?} content
     * @param {?} componentTmp
     * @return {?}
     */
    getTemplate(content, componentTmp) {
        if (this.isComponent(content)) {
            return componentTmp;
        }
        return this.isDirective(content) ? content.template : content;
    }
    /**
     * @param {?} __0
     * @return {?}
     */
    ngOnChanges({ content, context }) {
        // TODO: Keep an eye on private field, name can change
        /** @type {?} */
        const componentRef = (/** @type {?} */ ((!content &&
            context &&
            this.outlet &&
            this.outlet['_componentRef'])));
        if (componentRef) {
            componentRef.injector.get(ChangeDetectorRef).markForCheck();
        }
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
        if (this.isDirective(this.content)) {
            this.content.check();
        }
    }
}
PolymorpheusOutletComponent.decorators = [
    { type: Component, args: [{
                selector: 'polymorpheus-outlet, [polymorpheus-outlet]',
                template: "<ng-container\r\n    *ngIf=\"isTemplate(content) || isComponent(content)\"\r\n    #mutableContext=\"context\"\r\n    context\r\n    [ngTemplateOutlet]=\"getTemplate(content, component)\"\r\n    [ngTemplateOutletContext]=\"context\"\r\n>\r\n    <ng-template #component>\r\n        <ng-container\r\n            *ngIf=\"isComponent(content)\"\r\n            [ngComponentOutlet]=\"content.component\"\r\n            [ngComponentOutletInjector]=\"content | injector : mutableContext.context : injector\"\r\n        ></ng-container>\r\n    </ng-template>\r\n</ng-container>\r\n<ng-container *ngIf=\"primitive\">\r\n    <ng-container *ngIf=\"!template; else child\">{{primitive}}</ng-container>\r\n    <ng-template #child>\r\n        <ng-container\r\n            [ngTemplateOutlet]=\"template\"\r\n            [ngTemplateOutletContext]=\"{$implicit: primitive}\"\r\n        ></ng-container>\r\n    </ng-template>\r\n</ng-container>\r\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [':host { display: block; }']
            }] }
];
/** @nocollapse */
PolymorpheusOutletComponent.ctorParameters = () => [
    { type: Injector, decorators: [{ type: Inject, args: [Injector,] }] }
];
PolymorpheusOutletComponent.propDecorators = {
    content: [{ type: Input }],
    context: [{ type: Input }],
    template: [{ type: ContentChild, args: [TemplateRef,] }],
    outlet: [{ type: ViewChild, args: [NgComponentOutlet,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Helper directive, extracting first {\@link EmbeddedViewRef} context if it's present
 * @template C
 */
class ContextDirective {
    /**
     * @param {?} viewContainerRef
     */
    constructor(viewContainerRef) {
        this.viewContainerRef = viewContainerRef;
    }
    /**
     * @return {?}
     */
    get context() {
        /** @type {?} */
        const viewRef = (/** @type {?} */ (this.viewContainerRef.get(0)));
        return viewRef && viewRef.context;
    }
}
ContextDirective.decorators = [
    { type: Directive, args: [{
                selector: '[context]',
                exportAs: 'context',
            },] }
];
/** @nocollapse */
ContextDirective.ctorParameters = () => [
    { type: ViewContainerRef, decorators: [{ type: Inject, args: [ViewContainerRef,] }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Internal use {\@link Pipe} to create {\@link Injector}
 * only when either content or context change
 * @template C
 */
class InjectorPipe {
    /**
     * @param {?} content
     * @param {?} context
     * @param {?} injector
     * @return {?}
     */
    transform(content, context, injector) {
        return content.createInjector(injector, context);
    }
}
InjectorPipe.decorators = [
    { type: Pipe, args: [{
                name: 'injector',
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PolymorpheusModule {
}
PolymorpheusModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                declarations: [
                    PolymorpheusOutletComponent,
                    PolymorpheusTemplate,
                    ContextDirective,
                    InjectorPipe,
                ],
                exports: [PolymorpheusOutletComponent, PolymorpheusTemplate],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { PolymorpheusComponent, PolymorpheusTemplate, PolymorpheusOutletComponent, POLYMORPHEUS_CONTEXT, PolymorpheusModule, ContextDirective as ɵa, InjectorPipe as ɵb };

//# sourceMappingURL=tinkoff-ng-polymorpheus.js.map